{"version":3,"sources":["webpack:///./src/utils/filterPlaylist.ts","webpack:///./src/utils/graphql-hooks/useAllPrograms.tsx","webpack:///./src/utils/graphql-hooks/useAllArtists.tsx","webpack:///./src/utils/graphql-hooks/useAllCategories.tsx","webpack:///../node_modules/@material-ui/core/esm/internal/svg-icons/createSvgIcon.js"],"names":["getProgramsContainsValue","playlistKey","value","programs","filter","program","playlist","map","tune","indexOf","filterPlaylist","reduce","accum","curr","useAllPrograms","data","React","allProgram","edges","node","useAllTunes","useCorners","allTunes","corner","d","programsContainsCorner","length","sort","a","b","useSelectors","selector","programsContainsSelector","useAllArtists","group","item","id","removeMultiple","artist","fieldValue","tunes","kana","nation","img","youtube","useAllCategories","createSvgIcon","path","displayName","Component","props","ref","muiName"],"mappings":"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","file":"89c4646f4e4ad4ac57c7478a90be74386eaadac3-2d413c6d1b6af73e2ad9.js","sourcesContent":["import { AbstractProgram } from '../types';\nimport { ProgramPlaylist } from '../../graphql-types';\n\nexport function getAllTunes(programs: AbstractProgram[]): ProgramPlaylist[] {\n  return programs.reduce((accum, curr) => [...accum, ...curr.playlist], []);\n}\n\nexport function getProgramsContainsValue(\n  playlistKey: keyof ProgramPlaylist,\n  value: any\n) {\n  return (programs: AbstractProgram[]): AbstractProgram[] => {\n    return programs.filter(\n      program =>\n        program.playlist.map(tune => tune[playlistKey]).indexOf(value) >= 0\n    );\n  };\n}\n\nexport function filterPlaylist(playlistKey: keyof ProgramPlaylist, value: any) {\n  return (programs: AbstractProgram[]): ProgramPlaylist[] => {\n    return programs.reduce(\n      (accum, curr) => [\n        ...accum,\n        ...curr.playlist.filter(tune => tune[playlistKey] === value),\n      ],\n      []\n    );\n  };\n}\n\nexport function getPlaylistStrings(\n  playlist: ProgramPlaylist[],\n  key: keyof ProgramPlaylist\n): string[] {\n  return playlist.reduce((accum, curr) => {\n    if (accum.indexOf(curr[key]) >= 0) {\n      return accum;\n    } else {\n      return [...accum, curr[key]];\n    }\n  }, []);\n}\n","import * as React from 'react';\nimport { useStaticQuery, graphql } from 'gatsby';\nimport {\n  QueriedProgram,\n  ArtistItem,\n  CategoryItem,\n  CornerItem,\n  SelectorItem,\n} from '../../types';\nimport { getProgramsContainsValue, filterPlaylist } from '../filterPlaylist';\nimport { AllProgramQuery, ProgramPlaylist } from '../../../graphql-types';\n\nexport function useAllPrograms(): QueriedProgram[] {\n  //console.log('useAllPrograms');\n  const data = useStaticQuery<AllProgramQuery>(graphql`\n    query AllProgram {\n      allProgram(sort: { fields: week, order: ASC }) {\n        edges {\n          node {\n            id\n            title\n            date(formatString: \"YYYY-MM-DD\")\n            categories\n            fields {\n              slug\n            }\n            guests\n            playlist {\n              artist\n              corner\n              id\n              indexInWeek\n              index\n              kana\n              label\n              name\n              nation\n              producer\n              selector\n              title\n              week\n              year\n              youtube\n            }\n            subtitle\n            week\n            year\n          }\n        }\n      }\n    }\n  `);\n  return React.useMemo(() => {\n    //console.log('useAllPrograms useMemo');\n    return data.allProgram.edges.map(({ node }) => node);\n  }, []);\n}\n\nexport function useAllTunes(): ProgramPlaylist[] {\n  //console.log('useAllTunes');\n  const programs = useAllPrograms();\n  return React.useMemo(() => {\n    //console.log('useAllTunes useMemo');\n    return programs.reduce((accum, curr) => [...accum, ...curr.playlist], []);\n  }, []);\n}\n/*\nexport function useAllArtists(): ArtistItem[] {\n  console.log('useAllArtists');\n  const allTunes = useAllTunes();\n  return React.useMemo(() => {\n    console.log('useAllArtists useMemo');\n    return allTunes.reduce<ArtistItem[]>((accum, curr) => {\n      const existedIndex = accum.map(d => d[0]).indexOf(curr.artist);\n      if (existedIndex < 0) {\n        return [...accum, [curr.artist, curr.kana, curr.nation, [curr]]];\n      } else {\n        accum[existedIndex][3].push(curr);\n        return accum;\n      }\n    }, []);\n  }, []);\n}\n*/\n/*\nexport function useCategories(): CategoryItem[] {\n  //console.log('useCategories');\n  const programs = useAllPrograms();\n  return React.useMemo(() => {\n    console.log('useCategories useMemo');\n    const categories: CategoryItem[] = [];\n    programs\n      .filter(program => program.categories.length)\n      .forEach(program => {\n        program.categories.forEach(category => {\n          const existedIndex = categories.map(d => d[0]).indexOf(category);\n          if (existedIndex < 0) {\n            categories.push([category, [program]]);\n          } else {\n            categories[existedIndex][1].push(program);\n          }\n        });\n      });\n    return categories.sort((a, b) => b[1].length - a[1].length);\n  }, []);\n}\n*/\nexport function useCorners(): CornerItem[] {\n  //console.log('useCorners');\n  const programs = useAllPrograms();\n  const allTunes = useAllTunes();\n  return React.useMemo(() => {\n    //console.log('useCorners useMemo');\n    return allTunes\n      .filter(tune => tune.corner !== '')\n      .reduce<CornerItem[]>((accum, curr) => {\n        const existedIndex = accum.map(d => d[0]).indexOf(curr.corner);\n        if (existedIndex < 0) {\n          const programsContainsCorner = getProgramsContainsValue(\n            'corner',\n            curr.corner\n          )(programs);\n\n          return [\n            ...accum,\n            [\n              curr.corner,\n              programsContainsCorner,\n              filterPlaylist('corner', curr.corner)(programsContainsCorner)\n                .length,\n            ],\n          ];\n        } else {\n          return accum;\n        }\n      }, [])\n      .sort((a, b) => b[2] - a[2]);\n  }, []);\n}\n\nexport function useSelectors(): SelectorItem[] {\n  //console.log('useSelectors');\n  const programs = useAllPrograms();\n  const allTunes = useAllTunes();\n  return React.useMemo(() => {\n    //console.log('useSelectors useMemo');\n    return allTunes\n      .filter(d => d.selector.length && d.selector !== '草野マサムネ')\n      .reduce<SelectorItem[]>((accum, curr) => {\n        const existedIndex = accum.map(d => d[0]).indexOf(curr.selector);\n        if (existedIndex < 0) {\n          const programsContainsSelector = getProgramsContainsValue(\n            'selector',\n            curr.selector\n          )(programs);\n          return [\n            ...accum,\n            [\n              curr.selector,\n              programsContainsSelector,\n              filterPlaylist(\n                'selector',\n                curr.selector\n              )(programsContainsSelector).length,\n            ],\n          ];\n        } else {\n          return accum;\n        }\n      }, [])\n      .sort((a, b) => b[2] - a[2]);\n  }, []);\n}\n","import * as React from 'react';\nimport { useStaticQuery, graphql } from 'gatsby';\nimport { AllArtistsQuery, Program, ProgramPlaylist } from '../../../graphql-types';\n\nexport interface ArtistItem {\n  fieldValue: string;\n  kana?: string;\n  nation: string;\n  edges: ArtistEdge[];\n  tunes: ProgramPlaylist[];\n  img?: string;\n}\n\nexport function useAllArtists(): ArtistItem[] {\n  const data = useStaticQuery<AllArtistsQuery>(graphql`\n    query AllArtists {\n      allProgram(sort: { fields: date, order: ASC }) {\n        group(field: playlist___artist) {\n          edges {\n            node {\n              id\n              playlist {\n                artist\n                kana\n                nation\n                youtube\n              }\n            }\n          }\n          fieldValue\n        }\n      }\n    }\n  `);\n  return React.useMemo(() => {\n    return data.allProgram.group.map(item => {\n      const edges = removeMultiple(item.edges).map(({ node }) => ({\n        ...node,\n        playlist: node.playlist.filter(\n          ({ artist }) => artist === item.fieldValue\n        )\n      }));\n      const tunes = edges.reduce<Pick<ProgramPlaylist, 'artist' | 'kana' | 'youtube'>[]>((accum, curr) => [...accum, ...curr.playlist], []);\n      const [{ kana, nation }] = tunes;\n      const [img] = tunes\n        .filter(tune => tune.youtube !== '')\n        .map(tune => tune.youtube);\n      return {\n        fieldValue: item.fieldValue,\n        kana,\n        nation,\n        edges,\n        tunes,\n        img: img ? `https://i.ytimg.com/vi/${img}/0.jpg` : null\n      };\n    });\n  }, []);\n}\n\ninterface ArtistEdge {\n  node: Pick<Program, 'id'> & {\n    playlist: ArtistPlaylist;\n  };\n}\n\ntype ArtistPlaylist = Pick<ProgramPlaylist, 'artist' | 'kana' | 'nation' | 'youtube'>[];\n\nfunction removeMultiple(edges: ArtistEdge[]) {\n  return edges.reduce<ArtistEdge[]>((accum, curr) => {\n    if (accum.map(d => d.node.id).indexOf(curr.node.id) >= 0) return accum;\n    return [...accum, curr];\n  }, []);\n}\n","import * as React from 'react';\nimport { useStaticQuery, graphql } from 'gatsby';\nimport { AllCategoriesQuery } from '../../../graphql-types';\n\nexport function useAllCategories() {\n  const data = useStaticQuery<AllCategoriesQuery>(graphql`\n    query AllCategories {\n      allProgram(sort: { fields: week, order: ASC }) {\n        group(field: categories) {\n          fieldValue\n          edges {\n            node {\n              id\n              week\n              title\n              date(formatString: \"YYYY-MM-DD\")\n              fields {\n                slug\n              }\n            }\n          }\n        }\n      }\n    }\n  `);\n  return React.useMemo(() => {\n    return data.allProgram.group.sort(\n      (a, b) => b.edges.length - a.edges.length\n    );\n  }, []);\n}\n","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport SvgIcon from '../../SvgIcon';\nexport default function createSvgIcon(path, displayName) {\n  var Component = React.memo(React.forwardRef(function (props, ref) {\n    return /*#__PURE__*/React.createElement(SvgIcon, _extends({}, props, {\n      ref: ref\n    }), path);\n  }));\n\n  if (process.env.NODE_ENV !== 'production') {\n    Component.displayName = \"\".concat(displayName, \"Icon\");\n  }\n\n  Component.muiName = SvgIcon.muiName;\n  return Component;\n}"],"sourceRoot":""}