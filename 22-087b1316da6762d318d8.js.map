{"version":3,"sources":["webpack:///./src/utils/useAnimation.tsx","webpack:///./src/components/index/Stat.tsx"],"names":["useAnimation","easingName","duration","delay","elapsed","React","setTime","animationFrame","timerStop","start","onFrame","Date","now","loop","requestAnimationFrame","timerDelay","setTimeout","cancelAnimationFrame","clearTimeout","useAnimationTimer","n","Math","min","easing","linear","elastic","inExpo","pow","useStyles","makeStyles","theme","createStyles","root","margin","title","display","alignItems","value","maxWidth","spacing","textAlign","label","marginLeft","Stat","icon","classes","useInView","triggerOnce","ref","inView","Grid","item","xs","className","container","sm","Typography","variant","component","StatCore","animation","round","Stats","allProgram","edges","totalCount","group","tunesLength","reduce","accum","node","playlist","length","fontSize"],"mappings":"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","file":"22-087b1316da6762d318d8.js","sourcesContent":["import * as React from 'react';\n\ntype Easing = {\n  linear: (n: number) => number;\n  elastic: (n: number) => number;\n  inExpo: (n: number) => number;\n};\ntype EasingName = 'linear' | 'elastic' | 'inExpo';\n\n// Hook\nexport default function useAnimation(easingName: EasingName = 'linear', duration = 500, delay = 0) {\n  // The useAnimationTimer hook calls useState every animation frame ...\n  // ... giving us elapsed time and causing a rerender as frequently ...\n  // ... as possible for a smooth animation.\n  const elapsed = useAnimationTimer(duration, delay);\n  // Amount of specified duration elapsed on a scale from 0 - 1\n  const n = Math.min(1, elapsed / duration);\n  // Return altered value based on our specified easing function\n  return easing[easingName](n);\n}\n\n// Some easing functions copied from:\n// https://github.com/streamich/ts-easing/blob/master/src/index.ts\n// Hardcode here or pull in a dependency\nconst easing: Easing = {\n  linear: (n: number) => n,\n  elastic: (n: number) => n * (33 * n * n * n * n - 106 * n * n * n + 126 * n * n - 67 * n + 15),\n  inExpo: (n: number) => Math.pow(2, 10 * (n - 1)),\n};\n\nfunction useAnimationTimer(duration = 1000, delay = 0) {\n  const [elapsed, setTime] = React.useState(0);\n\n  React.useEffect(\n    () => {\n      let animationFrame: number;\n      let timerStop: NodeJS.Timeout;\n      let start: number;\n\n      // Function to be executed on each animation frame\n      function onFrame() {\n        setTime(Date.now() - start);\n        loop();\n      }\n\n      // Call onFrame() on next animation frame\n      function loop() {\n        animationFrame = requestAnimationFrame(onFrame);\n      }\n\n      function onStart() {\n        // Set a timeout to stop things when duration time elapses\n        timerStop = setTimeout(() => {\n          cancelAnimationFrame(animationFrame);\n          setTime(Date.now() - start);\n        }, duration);\n\n        // Start the loop\n        start = Date.now();\n        loop();\n      }\n\n      // Start after specified delay (defaults to 0)\n      const timerDelay = setTimeout(onStart, delay);\n\n      // Clean things up\n      return () => {\n        clearTimeout(timerStop);\n        clearTimeout(timerDelay);\n        cancelAnimationFrame(animationFrame);\n      };\n    },\n    [duration, delay] // Only re-run effect if duration or delay changes\n  );\n\n  return elapsed;\n}\n","import * as React from 'react';\nimport { useStaticQuery, graphql } from 'gatsby';\nimport Grid from '@material-ui/core/Grid';\nimport Typography from '@material-ui/core/Typography';\nimport { makeStyles, createStyles, Theme } from '@material-ui/core/styles';\nimport { useInView } from 'react-intersection-observer';\nimport useAnimation from '../../utils/useAnimation';\nimport { ProgramIcon, ArtistIcon, TuneIcon } from '../../icons';\nimport { StatQuery } from '../../../graphql-types';\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      margin: 'auto',\n    },\n    title: {\n      display: 'flex',\n      alignItems: 'center',\n    },\n    value: {\n      margin: 'auto',\n      maxWidth: theme.spacing(16),\n      textAlign: 'right',\n    },\n    label: {\n      marginLeft: '.5em',\n    },\n  })\n);\n\ninterface Props {\n  icon: JSX.Element;\n  value: number;\n  label: string;\n  title: string;\n}\n\nexport function Stat({ icon, value, label, title }: Props) {\n  const classes = useStyles();\n  const [ref, inView] = useInView({\n    triggerOnce: true,\n  });\n  return (\n    <Grid item xs={4} ref={ref} className={classes.root}>\n      <Grid container>\n        <Grid className={classes.title} item xs={12} sm={5}>\n          <Typography variant=\"h4\" component=\"span\">\n            {icon}\n          </Typography>\n          <Typography variant=\"body2\" component=\"span\">\n            {title}\n          </Typography>\n        </Grid>\n        <Grid item xs={12} sm={7}>\n          <div className={classes.value}>\n            <Typography variant=\"h4\" component=\"em\">\n              {inView ? <StatCore value={value} /> : <span>0</span>}\n            </Typography>\n            <Typography component=\"span\" className={classes.label}>\n              {label}\n            </Typography>\n          </div>\n        </Grid>\n      </Grid>\n    </Grid>\n  );\n}\n\nfunction StatCore({ value }: { value: number }) {\n  const animation = useAnimation('linear', value, 0);\n  return <span>{Math.round(value * animation)}</span>;\n}\n\nexport default function Stats() {\n  const { edges, totalCount, group } = useStaticQuery<StatQuery>(graphql`\n    query Stat {\n      allProgram {\n        edges {\n          node {\n            playlist {\n              id\n            }\n          }\n        }\n        totalCount\n        group(field: playlist___artist) {\n          fieldValue\n        }\n      }\n    }\n  `).allProgram;\n  const tunesLength = edges.reduce((accum, { node }) => accum + (node.playlist?.length ?? 0), 0);\n\n  return (\n    <Grid container>\n      <Stat icon={<ProgramIcon fontSize=\"inherit\" />} value={totalCount} title=\"放送\" label=\"回\" />\n      <Stat icon={<TuneIcon fontSize=\"inherit\" />} value={tunesLength} title=\"曲数\" label=\"曲\" />\n      <Stat icon={<ArtistIcon fontSize=\"inherit\" />} value={group.length} title=\"アーティスト\" label=\"組\" />\n    </Grid>\n  );\n}\n"],"sourceRoot":""}