{"version":3,"sources":["webpack:///./src/pages/page-2.tsx","webpack:///./src/components/SimpleYearsBar.tsx","webpack:///../node_modules/@material-ui/core/esm/ListItemAvatar/ListItemAvatar.js","webpack:///../node_modules/memoize-one/dist/memoize-one.esm.js","webpack:///../node_modules/react-window/dist/index.esm.js","webpack:///./src/utils/sortByYomi.ts","webpack:///./src/components/Artists.tsx","webpack:///./src/components/SimpleNationBar.tsx","webpack:///./src/components/ListItemLink.tsx"],"names":["SecondPage","data","categories","React","allProgram","edges","map","node","reduce","accum","curr","existedIndex","d","indexOf","sort","a","b","console","log","guests","allTunes","playlist","selectors","selector","kana","title","variant","component","key","useStyles","makeStyles","theme","createStyles","root","fontSize","fontWeight","typography","fontWeightBold","paddingTop","spacing","bar","height","display","overflow","borderRadius","barInner","justifyContent","textAlign","backgroundColor","palette","type","grey","color","transition","transitions","create","borderRight","flex","SimpleYearsBar","classes","years","tune","year","Math","floor","className","index","arrow","style","width","round","length","props","ref","other","context","ListContext","alignItems","alignItemsFlexStart","withStyles","minWidth","flexShrink","marginTop","name","areInputsEqual","newInputs","lastInputs","i","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","_i","arguments","this","apply","now","performance","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","requestAnimationFrame","tick","call","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","document","createElement","outerStyle","direction","innerDiv","innerStyle","appendChild","body","scrollLeft","removeChild","defaultItemKey$1","createListComponent","_ref","_class","_temp","getItemOffset","getEstimatedTotalSize","getItemSize","getOffsetForIndexAndAlignment","getStartIndexForOffset","getStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","List","_this","_instanceProps","_outerRef","_resetIsScrollingTimeoutId","state","instance","isScrolling","scrollDirection","scrollOffset","initialScrollOffset","scrollUpdateWasRequested","_callOnItemsRendered","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","_this$props","itemSize","layout","itemStyleCache","_getItemStyleCache","hasOwnProperty","_style","_offset","size","isHorizontal","position","top","_","__","___","_onScrollHorizontal","event","_event$currentTarget","currentTarget","clientWidth","scrollWidth","setState","prevState","max","min","_resetIsScrollingDebounced","_onScrollVertical","_event$currentTarget2","clientHeight","scrollHeight","scrollTop","_outerRefSetter","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps$1","_proto","prototype","scrollTo","scrollToItem","align","itemCount","componentDidMount","_this$props2","_callPropsCallbacks","componentDidUpdate","_this$props3","_this$state","componentWillUnmount","render","_this$props4","children","innerRef","innerElementType","innerTagName","itemData","_this$props4$itemKey","itemKey","outerElementType","outerTagName","useIsScrolling","_this$_getRangeToRend","_getRangeToRender","startIndex","stopIndex","items","_index","push","undefined","estimatedTotalSize","WebkitOverflowScrolling","willChange","pointerEvents","_this$_getRangeToRend2","_overscanStartIndex","_overscanStopIndex","_visibleStartIndex","_visibleStopIndex","_this$state2","_scrollDirection","_scrollOffset","_scrollUpdateWasRequested","_this$props5","overscanCount","_this$state3","overscanBackward","overscanForward","defaultProps","_ref2","_ref3","FixedSizeList","_ref4","lastItemOffset","maxOffset","minOffset","middleOffset","ceil","_ref5","offset","_ref6","numVisibleItems","_ref7","getYomi","artistName","the","slice","renderRow","artist","ListItemLink","button","to","NationAvatar","nation","ListItemText","primary","secondary","Chip","label","Artists","filter","artists","localeCompare","SimpleNationBar","useTheme","isDark","nations","background","getNationColor","getContrastText","renderLink","itemProps"],"mappings":"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","file":"component---src-pages-page-2-tsx-c2ec2f5c8f42fa8fa6a3.js","sourcesContent":["import * as React from 'react';\nimport { useStaticQuery, graphql } from 'gatsby';\nimport Typography from '@material-ui/core/Typography';\nimport Layout from 'gatsby-theme-typescript-material-ui/src/layout';\nimport SimpleNationBar from '../components/SimpleNationBar';\nimport SimpleYearsBar from '../components/SimpleYearsBar';\nimport Artists from '../components/Artists';\nimport { AllDataQuery } from '../../graphql-types';\n\nfunction SecondPage() {\n  const data = useStaticQuery<AllDataQuery>(graphql`\n    query AllData {\n      allProgram(sort: { fields: week, order: ASC }) {\n        edges {\n          node {\n            id\n            title\n            date\n            categories\n            fields {\n              slug\n            }\n            guests\n            playlist {\n              artist\n              corner\n              id\n              indexInWeek\n              index\n              kana\n              label\n              name\n              nation\n              producer\n              selector\n              title\n              week\n              year\n              youtube\n            }\n            subtitle\n            week\n            year\n          }\n          next {\n            title\n            fields {\n              slug\n            }\n            week\n          }\n          previous {\n            fields {\n              slug\n            }\n            title\n            week\n          }\n        }\n      }\n    }\n  `);\n  const categories = React.useMemo(\n    () =>\n      data.allProgram.edges\n        .map(({ node }) => node.categories)\n        .reduce((accum, curr) => [...accum, ...curr], [])\n        .reduce((accum, curr) => {\n          const existedIndex = accum.map(d => d[0]).indexOf(curr);\n          if (existedIndex < 0) {\n            return [...accum, [curr, 1]];\n          } else {\n            accum[existedIndex][1] += 1;\n            return accum;\n          }\n        }, [])\n        .sort((a, b) => b[1] - a[1]),\n    [data]\n  );\n  console.log(categories);\n\n  const guests = React.useMemo(\n    () =>\n      data.allProgram.edges\n        .map(({ node }) => node.guests)\n        .reduce((accum, curr) => [...accum, ...curr], [])\n        .reduce((accum, curr) => {\n          const existedIndex = accum.map(d => d[0]).indexOf(curr);\n          if (existedIndex < 0) {\n            return [...accum, [curr, 1]];\n          } else {\n            accum[existedIndex][1] += 1;\n            return accum;\n          }\n        }, [])\n        .sort((a, b) => b[1] - a[1]),\n    [data]\n  );\n  console.log(guests);\n\n  const allTunes = React.useMemo(\n    () =>\n      data.allProgram.edges\n        .map(({ node }) => node.playlist)\n        .reduce((accum, curr) => [...accum, ...curr]),\n    [data]\n  );\n\n  const selectors = React.useMemo(\n    () =>\n      allTunes\n        .map(d => d.selector)\n        .reduce((accum, curr) => {\n          const existedIndex = accum.map(d => d[0]).indexOf(curr);\n          if (existedIndex < 0) {\n            return [...accum, [curr, 1]];\n          } else {\n            accum[existedIndex][1] += 1;\n            return accum;\n          }\n        }, [])\n        .sort((a, b) => b[1] - a[1] || a.kana - b.kana),\n    [allTunes]\n  );\n\n  return (\n    <Layout title=\"Second Page\">\n      <Typography variant=\"h5\" component=\"h3\">\n        Summary\n      </Typography>\n      <SimpleNationBar playlist={allTunes} />\n      <SimpleYearsBar playlist={allTunes} />\n      <Typography variant=\"h5\" component=\"h3\">\n        カテゴリー\n      </Typography>\n      <div>\n        {categories.map(d => (\n          <Typography key={d[0]} variant=\"body1\">\n            {d[0]} {d[1]}\n          </Typography>\n        ))}\n      </div>\n      <Typography variant=\"h5\" component=\"h3\">\n        ゲスト\n      </Typography>\n      <div>\n        {guests.map(d => (\n          <Typography key={d[0]} variant=\"body1\">\n            {d[0]} {d[1]}\n          </Typography>\n        ))}\n      </div>\n      <Typography variant=\"h5\" component=\"h3\">\n        選曲者\n      </Typography>\n      <div>\n        {selectors.map(d => (\n          <Typography key={d[0]} variant=\"body1\">\n            {d[0]} {d[1]}\n          </Typography>\n        ))}\n      </div>\n      <Artists />\n    </Layout>\n  );\n}\n\nexport default SecondPage;\n","import * as React from 'react';\nimport {\n  makeStyles,\n  createStyles,\n  Theme,\n} from '@material-ui/core/styles';\nimport Tooltip from '@material-ui/core/Tooltip';\nimport { ProgramPlaylist } from '../../graphql-types';\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      fontSize: '.5em',\n      fontWeight: theme.typography.fontWeightBold,\n      paddingTop: theme.spacing(1),\n    },\n    bar: {\n      height: 16,\n      display: 'flex',\n      overflow: 'hidden',\n      borderRadius: 8,\n    },\n    barInner: {\n      display: 'flex',\n      justifyContent: 'center',\n      textAlign: 'center',\n      backgroundColor:\n        theme.palette.type === 'dark'\n          ? theme.palette.grey[700]\n          : theme.palette.grey[300],\n      color:\n        theme.palette.type === 'dark'\n          ? theme.palette.grey[300]\n          : theme.palette.grey[700],\n      transition: theme.transitions.create(['width', 'background']),\n      borderRight: '.5px solid silver',\n      '&:last-child': {\n        borderRight: 'none',\n        flex: 1,\n      },\n    },\n  })\n);\n\ninterface Props {\n  playlist: Pick<ProgramPlaylist, 'year'>[];\n}\n\nfunction SimpleYearsBar({ playlist }: Props) {\n  const classes = useStyles();\n  const years = React.useMemo(\n    () =>\n      playlist\n        .map(tune => tune.year)\n        .reduce((accum, curr) => {\n          // [[197, 1], [198, 2]]\n          const existedIndex = accum\n            .map(d => d[0])\n            .indexOf(Math.floor(curr / 10));\n          if (existedIndex < 0) {\n            return [...accum, [Math.floor(curr / 10), 1]];\n          } else {\n            accum[existedIndex][1] += 1;\n            return accum;\n          }\n        }, [])\n        .sort((a, b) => a[0] - b[0])\n        .map(d => [d[0] * 10, d[1]]),\n    [playlist]\n  );\n  return (\n    <div className={classes.root}>\n      <div className={classes.bar}>\n        {years.map((years, index) => (\n          <Tooltip key={index} arrow title={`${years[1]}曲`}>\n            <div\n              key={index}\n              className={classes.barInner}\n              style={{\n                width: `${Math.round((years[1] * 100) / playlist.length)}%`,\n              }}\n            >\n              <span>{years[0]}s</span>\n            </div>\n          </Tooltip>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default SimpleYearsBar;\n","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport withStyles from '../styles/withStyles';\nimport ListContext from '../List/ListContext';\nexport var styles = {\n  /* Styles applied to the root element. */\n  root: {\n    minWidth: 56,\n    flexShrink: 0\n  },\n\n  /* Styles applied to the root element when the parent `ListItem` uses `alignItems=\"flex-start\"`. */\n  alignItemsFlexStart: {\n    marginTop: 8\n  }\n};\n/**\n * A simple wrapper to apply `List` styles to an `Avatar`.\n */\n\nvar ListItemAvatar = React.forwardRef(function ListItemAvatar(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      other = _objectWithoutProperties(props, [\"classes\", \"className\"]);\n\n  var context = React.useContext(ListContext);\n  return React.createElement(\"div\", _extends({\n    className: clsx(classes.root, className, context.alignItems === 'flex-start' && classes.alignItemsFlexStart),\n    ref: ref\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? ListItemAvatar.propTypes = {\n  /**\n   * The content of the component – normally `Avatar`.\n   */\n  children: PropTypes.element.isRequired,\n\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object.isRequired,\n\n  /**\n   * @ignore\n   */\n  className: PropTypes.string\n} : void 0;\nexport default withStyles(styles, {\n  name: 'MuiListItemAvatar'\n})(ListItemAvatar);","function areInputsEqual(newInputs, lastInputs) {\n  if (newInputs.length !== lastInputs.length) {\n    return false;\n  }\n\n  for (var i = 0; i < newInputs.length; i++) {\n    if (newInputs[i] !== lastInputs[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n  if (isEqual === void 0) {\n    isEqual = areInputsEqual;\n  }\n\n  var lastThis;\n  var lastArgs = [];\n  var lastResult;\n  var calledOnce = false;\n\n  function memoized() {\n    var newArgs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      newArgs[_i] = arguments[_i];\n    }\n\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult;\n    }\n\n    lastResult = resultFn.apply(this, newArgs);\n    calledOnce = true;\n    lastThis = this;\n    lastArgs = newArgs;\n    return lastResult;\n  }\n\n  return memoized;\n}\n\nexport default memoizeOne;","import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.object.to-string\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.weak-set\";\nimport \"core-js/modules/es6.date.now\";\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose'; // Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\n\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\n\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\n\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();\n    devWarningsOverscanRowsColumnsCount = /*#__PURE__*/new WeakSet();\n    devWarningsTagName = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class, _temp;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _temp = _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent); // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n\n\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _style;\n\n          itemStyleCache[key] = style = (_style = {\n            position: 'absolute'\n          }, _style[direction === 'rtl' ? 'right' : 'left'] = getColumnOffset(_this.props, columnIndex, _this._instanceProps), _style.top = getRowOffset(_this.props, rowIndex, _this._instanceProps), _style.height = getRowHeight(_this.props, rowIndex, _this._instanceProps), _style.width = getColumnWidth(_this.props, columnIndex, _this._instanceProps), _style);\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _temp;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = /*#__PURE__*/new WeakSet();\n    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class, _temp;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _temp = _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent); // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n\n\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _style;\n\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          itemStyleCache[index] = style = (_style = {\n            position: 'absolute'\n          }, _style[direction === 'rtl' ? 'right' : 'left'] = isHorizontal ? _offset : 0, _style.top = !isHorizontal ? _offset : 0, _style.height = !isHorizontal ? size : '100%', _style.width = isHorizontal ? size : '100%', _style);\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var itemCount = this.props.itemCount;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1));\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props2 = this.props,\n          direction = _this$props2.direction,\n          initialScrollOffset = _this$props2.initialScrollOffset,\n          layout = _this$props2.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          layout = _this$props3.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemCount = _this$props4.itemCount,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,\n          layout = _this$props4.layout,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props5 = this.props,\n          itemCount = _this$props5.itemCount,\n          overscanCount = _this$props5.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _temp;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\nvar FixedSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\nvar FixedSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n}); // Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\n\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n} // It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, [\"style\"]);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, [\"style\"]);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n} // It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { VariableSizeGrid, VariableSizeList, FixedSizeGrid, FixedSizeList, areEqual, shouldComponentUpdate };","/*\nexport default function sortByYomi(a: YamlPlaylist, b: YamlPlaylist) {\n                 return getYomi(a) !== getYomi(b)\n                   ? getYomi(a).localeCompare(getYomi(b))\n                   : sortByYear(a, b);\n               }\n               */\nexport function getYomi(artistName: string, kana: string) {\n  const the = artistName.slice(0, 4);\n  if (the === 'The ' || the === 'THE ' || the === 'the ')\n    return artistName.slice(4);\n  return kana || artistName;\n}\n\nexport function encodeArtistName(artistName: string) {\n  return encodeURIComponent(artistName.replace(/[' ']+/g, '_'));\n}\n\nexport function decodeArtistName(artistName: string) {\n  return decodeURIComponent(artistName.replace(/['_']+/g, ' '));\n}\n","import * as React from 'react';\nimport { useStaticQuery, graphql } from 'gatsby';\nimport ListItemAvatar from '@material-ui/core/ListItemAvatar';\nimport ListItemText from '@material-ui/core/ListItemText';\nimport Chip from '@material-ui/core/Chip';\nimport { FixedSizeList, ListChildComponentProps } from 'react-window';\nimport ListItemLink from './ListItemLink';\nimport NationAvatar from './NationAvatar';\nimport { getYomi } from '../utils/sortByYomi';\nimport { ArtistItem } from '../types';\nimport { AllDataQuery } from '../../graphql-types';\n\n/*\nfunction SkeletonListItem(props: any) {\n  return (\n    <ListItem button {...props}>\n      <ListItemAvatar>\n        <Skeleton variant=\"circle\" width={40} height={40} />\n      </ListItemAvatar>\n      <ListItemText primary={<Skeleton variant=\"text\" width={200} />} />\n    </ListItem>\n  );\n}\n*/\n\nfunction renderRow({ index, style, data }: ListChildComponentProps) {\n  const artist: ArtistItem = data[index];\n  return (\n    <ListItemLink\n      button\n      style={style}\n      key={index}\n      to={\n        artist[3].length > 1\n          ? `/artist/${artist[0]}/`\n          : `/artist/?name=${artist[0]}`\n      }\n    >\n      <ListItemAvatar>\n        <NationAvatar nation={artist[2]} />\n      </ListItemAvatar>\n      <ListItemText primary={artist[0]} secondary={artist[1] || null} />\n      <Chip label={artist[3].length} />\n    </ListItemLink>\n  );\n}\n\ninterface Props {\n  width?: number;\n  height?: number;\n  itemSize?: number;\n  filter?: (artist: ArtistItem) => boolean;\n  sort?: (a: ArtistItem, b: ArtistItem) => number;\n}\n\nfunction Artists({\n  width = 320,\n  height = 480,\n  itemSize = 60,\n  filter = () => true,\n  sort = (a, b) => b[3].length - a[3].length\n}: Props) {\n  const data = useStaticQuery<AllDataQuery>(graphql`\n    query {\n      allProgram(sort: { fields: week, order: ASC }) {\n        edges {\n          node {\n            id\n            title\n            date(formatString: \"YYYY-MM-DD\")\n            categories\n            fields {\n              slug\n            }\n            guests\n            subtitle\n            week\n            year\n            playlist {\n              artist\n              corner\n              id\n              indexInWeek\n              index\n              kana\n              label\n              name\n              nation\n              producer\n              selector\n              title\n              week\n              year\n              youtube\n            }\n          }\n        }\n      }\n    }\n  `);\n  const allTunes = React.useMemo(\n    () =>\n      data.allProgram.edges\n        .map(({ node }) => node.playlist)\n        .reduce((accum, curr) => [...accum, ...curr]),\n    [data]\n  );\n  // [artist, kana, nation, playlist][]\n  const artists = React.useMemo(\n    () =>\n      allTunes\n        .reduce<ArtistItem[]>((accum, curr) => {\n          const existedIndex = accum.map(d => d[0]).indexOf(curr.artist);\n          if (existedIndex < 0) {\n            return [...accum, [curr.artist, curr.kana, curr.nation, [curr]]];\n          } else {\n            accum[existedIndex][3].push(curr);\n            return accum;\n          }\n        }, [])\n        .filter(filter)\n        .sort(\n          (a, b) =>\n            sort(a, b) || getYomi(a[0], a[1]).localeCompare(getYomi(b[0], b[1]))\n        ),\n    [allTunes, filter, sort]\n  );\n\n  return (\n    <FixedSizeList width={width} height={height} itemCount={artists.length} itemSize={itemSize} itemData={artists}>\n      {renderRow}\n    </FixedSizeList>\n  );\n}\n\nexport default Artists;\n","import * as React from 'react';\nimport {\n  makeStyles,\n  createStyles,\n  Theme,\n  useTheme,\n} from '@material-ui/core/styles';\nimport Tooltip from '@material-ui/core/Tooltip';\nimport getNationColor from '../utils/getNationColor';\nimport { ProgramPlaylist } from '../../graphql-types';\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      fontSize: '.5em',\n      fontWeight: theme.typography.fontWeightBold,\n    },\n    bar: {\n      height: 16,\n      display: 'flex',\n      overflow: 'hidden',\n      borderRadius: 8,\n    },\n    barInner: {\n      display: 'flex',\n      justifyContent: 'center',\n      transition: theme.transitions.create(['width', 'background']),\n      '&:last-child': {\n        flex: 1,\n      },\n    },\n  })\n);\n\ninterface Props {\n  playlist: Pick<ProgramPlaylist, 'nation'>[];\n}\n\nfunction SimpleNationBar({ playlist }: Props) {\n  const classes = useStyles();\n  const theme = useTheme();\n  const isDark = theme.palette.type === 'dark';\n  const nations = React.useMemo(\n    () =>\n      playlist\n        .map(tune => tune.nation)\n        .reduce(\n          (accum, curr) =>\n            accum.map(d => d[0]).indexOf(curr) < 0\n              ? [\n                  ...accum,\n                  [curr, playlist.filter(d => d.nation === curr).length],\n                ]\n              : [...accum],\n          []\n        )\n        .sort((a, b) => b[1] - a[1]),\n    [playlist]\n  );\n\n  return (\n    <div className={classes.root}>\n      <div className={classes.bar}>\n        {nations.map((nation, index) => (\n          <Tooltip key={index} arrow title={`${nation[1]}曲`}>\n            <div\n              key={index}\n              className={classes.barInner}\n              style={{\n                width: `${Math.round((nation[1] * 100) / playlist.length)}%`,\n                background: getNationColor(nation[0], isDark),\n                color: theme.palette.getContrastText(\n                  getNationColor(nation[0], isDark)\n                ),\n              }}\n            >\n              <span>{nation[0]}</span>\n            </div>\n          </Tooltip>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default SimpleNationBar;\n","import * as React from 'react';\nimport { Link as GatsbyLink, GatsbyLinkProps } from 'gatsby';\nimport ListItem, { ListItemProps } from '@material-ui/core/ListItem';\n\ninterface ListItemLinkProps<TState> extends ListItemProps {\n  to: string;\n  state?: TState;\n}\n\nfunction ListItemLink<TState>(props: ListItemLinkProps<TState>) {\n  const { to, children } = props;\n\n  const renderLink = React.useMemo(\n    () =>\n      React.forwardRef<any, Omit<GatsbyLinkProps<TState>, 'to'>>(\n        (itemProps, ref) => <GatsbyLink to={to} ref={ref} {...itemProps} />\n      ),\n    [to]\n  );\n\n  return (\n    <ListItem component={renderLink} {...props}>\n      {children}\n    </ListItem>\n  );\n}\n\nexport default ListItemLink;\n"],"sourceRoot":""}